\section{Аналитическая часть}

\subsection{Расстояние Левенштейна}

Расстояние Левенштейна --- метрика, определяющая понятие расстояния между двумя последовательностями символов, как минимального количества редакторских операций вставки ($I$, от англ. insert), замены ($R$, от англ. replace) и удаления ($D$, от англ. delete), необходимых для преобразования одной строки в другую \cite{lev}.
Для каждой операции должна быть определена её стоимость.
Введём обозначения для стоимостей.
Пусть:
\begin{enumerate}
    \item $w(a, b)$ --- цена замены символа $a$ на $b$;
    \item $w(\lambda, b)$ --- цена вставки символа $b$;
    \item $w(a, \lambda)$ --- цена удаления символа $a$.
\end{enumerate}

Определим стоимости операций:
\begin{equation}
    w(a, b) = \begin{cases}
        1,\ \text{если}\ a \neq b; \\
        0,\ \text{иначе}.
    \end{cases}
    \label{eq:w}
\end{equation}

Отсутствие операций в случае совпадения символов будем обозначать за $M$ (от англ. match).

Введём в рассмотрение функцию $D(S_1[1 .. i], S_2[1 .. j])$, значнием которой является редакционное расстояние между подстроками $S_1[1 .. i]$ и $S_2[1 .. j]$, где $S_1[1 .. i]$ --- подстрока $S_1$ длины $i$. Так, если $S_1 = \text{\texttt{''скат''}}$, то $S_1[1 .. 0] = \lambda$, $S_1[1 .. 1] = \text{\texttt{''с''}}$, $S_1[1 .. 2] = \text{\texttt{''ск''}}$.
Расстояние Левенштейна между строками $S_1$ и $S_2$ длин $L_1$ и $L_2$ соответственно вычисляется по рекуррентной формуле:
\begin{multline}
    D(S_1[1 .. i], S_2[1 .. j]) = \\
    = \begin{cases}
        \begin{aligned}
            &\mathrm{max}(i,\ j), &i \cdot j = 0; \\
            &\mathrm{min} \begin{cases}
                D(S_1[1 .. i], S_2[1 .. j - 1]) + 1, \\
                D(S_1[1 .. i - 1], S_2[1 .. j]) + 1, \\
                D(S_1[1 .. i - 1], S_2[1 .. j - 1]) + w(S_1[i], S_2[j]),
            \end{cases} &i \cdot j \neq 0,
        \end{aligned}
    \end{cases}
    \label{eq:lev}
\end{multline}

где $i = L_1$, $j = L_2$.
% где $i = \overline{0;L_1}$, $j = \overline{0;L_2}$.

\subsubsection{Итерационный алгоритм нахождения расстояния Левенштейна}

Рекурсивная реализация алгоритма Левенштейна малоэффективна по времени при больших $L_1$ и $L_2$, так как производится много повторных, лишних вычислений.
Реализацию можно оптимизировать с помощью динамического программирования.
Например, ввести матрицу размерности $(L_1 + 1) \times (L_2 + 1)$ и заполнять её промежуточными значениями $D(S_1[1 .. i], S_2[1 .. j])$, используя их затем по ходу вычислений.
Значения в ячейках $[i][j]$ ($i$-я строка, $j$-й столбец) матрицы равны значениям $D(S_1[1 .. i], S_2[1 .. j])$ соответственно.
Можно заметить, что всю матрицу для вычислений хранить не обязательно --- двух строк будет достаточно.

\subsection{Расстояние Дамерау --- Левенштейна}

Расстояние Дамерау --- Левенштейна --- метрика, которая определяет расстояние между двумя последовательностями символов, как и расстояние Левенштейна, но к исходному набору редакторских операций добавляется ещё одна --- транспозиция (T, от англ. transposition).
Операция транспозиции меняет местами соседние буквы в строке.
Обозначим её стоимость: $w(ab, ba) = 1$.

Расстояние Дамерау --- Левенштейна $\mathcal{D}(S_1, S_2)$ между строками $S_1$ и $S_2$ длин $L_1$ и $L_2$ соответственно может быть вычислено по рекуррентной формуле:
\begin{multline}
    \mathcal{D}(S_1[1 .. i], S_2[1 .. j]) = \\
    = \begin{cases}
        \begin{aligned}
            &\mathrm{max}(i,\ j), &\text{если}\ i \cdot j = 0; \\
            &\mathrm{min} \begin{cases}
                \mathcal{D}(S_1[1 .. i], S_2[1 .. j - 1]) + 1, \\
                \mathcal{D}(S_1[1 .. i - 1], S_2[1 .. j]) + 1, \\
                \mathcal{D}(S_1[1 .. i - 1], S_2[1 .. j - 1]) + w(S_1[i], S_2[j]), \\
                \mathcal{D}(S_1[1 .. i - 2], S_2[1 .. j - 2]) + 1,
                \end{cases} &\parbox{4cm}{
                    \raggedleft если $i > 1,\ j > 1$,
                    $S_1[i] = S_2[j - 1]$,
                    $S_1[i - 1] = S_2[j]$;
                } \\ % XXX: how to do auto width?
            &\mathrm{min} \begin{cases}
                \mathcal{D}(S_1[1 .. i], S_2[1 .. j - 1]) + 1, \\
                \mathcal{D}(S_1[1 .. i - 1], S_2[1 .. j]) + 1, \\
                \mathcal{D}(S_1[1 .. i - 1], S_2[1 .. j - 1]) + w(S_1[i], S_2[j]),
                \end{cases} &\text{иначе},
        \end{aligned}
    \end{cases}
    \label{eq:damlev}
\end{multline}

где $i = L_1$, $j = L_2$.

\subsubsection{Рекурсивный алгоритм нахождения расстояния Дамерау --- Левенштейна}

Рекурсивный алгоритм нахождения расстояния Дамерау --- Левенштейна реализует рекуррентную формулу (\ref{eq:damlev}). Таким образом, верно следующее:
\begin{enumerate}
    \item $\mathcal{D}(\lambda, \lambda) = 0$, --- для преобразования пустой строки в пустую строку требуется $0$ операций вставки, замены, удаления и транспозиции;
    \item $\mathcal{D}(S_1, \lambda) = |S_1|$ (длина $S_1$), --- для преобразования строки $S_1$ в пустую строку требуется $|S_1|$ операций (удаления);
    \item $\mathcal{D}(\lambda, S_2) = |S_2|$, --- для преобразования пустой строки в строку $S_2$ требуется $|S_2|$ операций (вставки);
    \item $\mathcal{D}(c_1, c_2) = \begin{cases}
            \begin{aligned}
                1,\ &c_1 \neq c_2; \\
                0,\ &c_1 = c_2,
            \end{aligned}
    \end{cases} $ --- для преобразования одного символа в другой требуется $1$ операция (замены), если символы отличаются, и $0$ операций, если символы совпадают;
    \item Для преобразования одной пары символов в другую: \\
        $\mathcal{D}(c_1c_2, c_3c_4) = \begin{cases}
            \begin{aligned}
                0,\ &c_1 = c_3,\ c_2 = c_4;\ //\ MM \\
                1,\ &c_1 = c_3,\ c_2 \neq c_4;\ //\ MR \\
                1,\ &c_1 \neq c_3,\ c_2 = c_4;\ //\ RM \\
                1,\ &c_1 = c_4,\ c_2 = c_3;\ //\ T \\
                2,\ &\text{иначе};\ //\ RR
            \end{aligned}
        \end{cases} $
    % \item Для преобразования строки $S_1$, $|S_1| \geq 2$ в строку $S_2$, $|S_2| \geq 2$: $$
    \item Пусть $S_1 = S_1'c_2 = S_1''c_1c_2$, $S_2 = S_2'c_4 = S_2''c_3c_4$, где $S_1'$ и $S_2'$ --- строки $S_1$ и $S_2$ без последних символов, $S_1''$ и $S_2''$ --- строки $S_1$ и $S_2$ без двух последних символов, а $c_1c_2$ и $c_3c_4$ --- пары их последних символов соответственно. $$
    \mathcal{D}(S_1, S_2) = \mathrm{min} \begin{cases}
        % \begin{aligned}
        % \mathcal{D}(S_1''c_1c_2, S_2''c_3) + 1, \\
        % \mathcal{D}(S_1''c_1, S_2''c_3c_4) + 1, \\
        % \mathcal{D}(S_1''c_1, S_2''c_3) + w(c_2, c_4), \\
        % \mathcal{D}(S_1'', S_2''),\ &\text{если $c_2 = c_3,\ c_1 = c_4$}.
        \mathcal{D}(S_1'c_2, S_2') + 1, \\
        \mathcal{D}(S_1', S_2'c_4) + 1, \\
        \mathcal{D}(S_1', S_2') + w(c_2, c_4), \\
        \mathcal{D}(S_1'', S_2'') + 1,\ &\text{если $c_2 = c_3,\ c_1 = c_4$}.
        % \end{aligned}
    \end{cases}
        $$
\end{enumerate}

Можно заметить, что $\mathcal{D}(S_1, S_2)$ вычисляется как минимальная длина последовательности редакторских операций, которыми можно преобразовать строку $S_1$ в $S_2'$ плюс цена вставки последнего символа из $S_2$, строку $S_1'$ в $S_2$ плюс цена удаления последнего символа из $S_1$, строку $S_1'$ в $S_2'$ плюс цена замены последних символов строк $S_1$ и $S_2$, строку $S_1''$ в $S_2''$ плюс цена транспозиции двух последних символов строк, если она возможна.
Для любых подстрок $\mathcal{S}_1$ и $\mathcal{S}_2$ строк $S_1$ и $S_2$, $\mathcal{D}(\mathcal{S}_1, \mathcal{S}_2)$ вычисляет минимальное количество редакторских операций.
Следовательно, $\mathcal{D}(S_1, S_2)$ действительно считает расстояние Дамерау --- Левенштейна для произвольных строк строк $S_1$ и $S_2$.

% По индукции докажем, что формула (\ref{eq:damlev}) действительно находит минимальное количество редакторских операций для произвольных строк $S_1$ и $S_2$.
% Пусть $S_1 = S_1''c_1c_2$, $S_2 = S_2''c_3c_4$, где $S_1''$ и $S_2''$ --- строки $S_1$ и $S_2$ без двух последних символов, а $c_1c_2$ и $c_3c_4$ --- пары их последних символов соответственно.
% Предположим, что $\mathcal{D}(S_1'', S_2'') = N$ --- минимальное количество редакторских операций, необходимых для преобразования строки $S_1''$ в $S_2''$.
% Покажем, что тогда $\mathcal{D}(S_1, S_2) = \mathcal{D}(S_1''c_1c_2, S_2''c_3c_4)$ --- минимальное количество редакторских операций, необходимых для преобразования строки $S_1$ в $S_2$.
% По определению, из (\ref{eq:damlev}):
% \begin{equation}
%     \mathcal{D}(S_1''c_1c_2, S_2''c_3c_4) = \mathrm{min} \begin{cases}
%         % \begin{aligned}
%         \mathcal{D}(S_1''c_1c_2, S_2''c_3) + 1, \\
%         \mathcal{D}(S_1''c_1, S_2''c_3c_4) + 1, \\
%         \mathcal{D}(S_1''c_1, S_2''c_3) + w(c_2, c_4), \\
%             N + 1,\ &\text{если $c_2 = c_3,\ c_1 = c_4$}.
%         % \end{aligned}
%     \end{cases}
%     \label{eq:dle1}
% \end{equation}

% Заметим, что из $\mathcal{D}(S_1'', S_2'') = N$ следует верность хотя бы одного из утверждений:
% \begin{enumerate}
%     \item $\mathcal{D}(S_1''[1..|S_1''| - 2], S_2''[1..|S_2''| - 2]) = N - 1$;
%     \item $\mathcal{D}(S_1''[1..|S_1''| - 1], S_2''[1..|S_2''| - 1]) = N - 1$ или $N$;
%     \item $\mathcal{D}(S_1'', S_2''[1..|S_2''| - 1]) = N - 1$;
%     \item $\mathcal{D}(S_1''[1..|S_1''| - 1], S_2'') = N - 1$,
% \end{enumerate}

% причём, в случае верности одного, остальные утверждения становятся справедливыми со знаком $\geq$ вместо $=$.
% Это рассуждение используется далее в $(*)$.
% \begin{multline}
%     % \mathcal{D}(S_1''c_1c_2, S_2''c_3) =
%     \mathcal{D}(S_1'c_2, S_2') = \\
%     = \begin{cases}
%         \begin{aligned}
%             &\mathrm{min} \begin{cases}
%                 \mathcal{D}(S_1'c_2, S_2'') + 1, \\
%                 \mathcal{D}(S_1', S_2') + 1, \\
%                 \mathcal{D}(S_1', S_2'') + w(c_2, c_3) \geq N, \\
%                 \geq N - 1 + 1,\ (*)\\
%             \end{cases} &\parbox{6cm}{
%                 \raggedleft если $|S_1'c_2|>1,\ |S_2'|>1$,
%                 % $c_2 = S_2''c_3[1..|S_2''c_3| - 1]$,
%                 $c_2 = S_2''c_3[|S_2''|]$,
%                 $c_1 = c_3$;
%             } \\
%             &\mathrm{min} \begin{cases}
%                 \mathcal{D}(S_1'c_2, S_2'') + 1, \\
%                 \mathcal{D}(S_1', S_2') + 1, \\
%                 \mathcal{D}(S_1', S_2'') + w(c_2, c_3) \geq N, \\
%             \end{cases} &\text{иначе}.
%         \end{aligned}
%     \end{cases}
%     \label{eq:dle2}
% \end{multline}

% \begin{multline}
%     \mathcal{D}(S_1''c_1c_2, S_2''c_3) = \\
%     = \begin{cases}
%         \begin{aligned}
%             &\mathrm{min} \begin{cases}
%                 \mathcal{D}(S_1''c_1c_2, S_2'') + 1, \\
%                 \mathcal{D}(S_1'', S_2''c_3c_4) + 1, \\
%                 N + w(c_1, c_3) \geq N, \\
%                 \geq N - 1 + 1,\ (*)\\
%             \end{cases} &\parbox{6cm}{
%                 \raggedleft если $|S_1''c_1c_2|>1,\ |S_2''c_3|>1$,
%                 % $c_2 = S_2''c_3[1..|S_2''c_3| - 1]$,
%                 $c_2 = S_2''c_3[|S_2''|]$,
%                 $c_1 = c_3$;
%             } \\
%             &\mathrm{min} \begin{cases}
%                 \mathcal{D}(S_1''c_1c_2, S_2'') + 1, \\
%                 \mathcal{D}(S_1'', S_2''c_3c_4) + 1, \\
%                 N + w(c_1, c_3) \geq N, \\
%             \end{cases} &\text{иначе}.
%         \end{aligned}
%     \end{cases}
%     \label{eq:dle2}
% \end{multline}
% XXX aoaoaoaoaoaoaaoaooaaoaooaaaoaoaoaoaoaoaaoaaoaoaoaoaoaaoaoaoaaoaoaoaoo why

\subsubsection{Рекурсивный с кешированием алгоритм нахождения расстояния Дамерау --- Левенштейна}

\subsubsection{Итерационный алгоритм нахождения расстояния Дамерау --- Левенштейна}
